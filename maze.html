<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Maze - Dynamic Horror</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; justify-content: center; align-items: center; z-index: 10; }
        
        /* Red pulse overlay when enemy is close */
        #danger-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            box-shadow: inset 0 0 0px rgba(255, 0, 0, 0);
            transition: box-shadow 0.3s ease;
            z-index: 5;
        }

        #crosshair { position: absolute; width: 6px; height: 6px; background: rgba(255,255,255,0.8); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 6; }
        
        #msg { background: rgba(0,0,0,0.9); color: white; padding: 30px; border: 2px solid #00ff00; pointer-events: auto; text-align: center; cursor: pointer; }
        
        #stamina-container {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 300px; height: 10px; background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3); display: none; z-index: 11;
        }
        #stamina-bar { width: 100%; height: 100%; background: #0088ff; }
    </style>
</head>
<body>

    <div id="danger-overlay"></div>
    <div id="crosshair"></div>
    
    <div id="stamina-container">
        <div id="stamina-bar"></div>
    </div>

    <div id="ui">
        <div id="msg" onclick="startGame()">
            <h2 id="status-title" style="color:#00ff00">MAZE RUNNER</h2>
            <p id="status-desc">The ghost is faster when you're tired.<br>Reach the Portal Door.</p>
            <p style="font-size: 0.8em; color: #888; margin-top: 20px;">Click to Start & Music</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const WALL_SIZE = 20;
        const MAZE_SIZE = 21;
        const PLAYER_HEIGHT = 5;
        const WALK_SPEED = 0.8;
        const RUN_SPEED = 1.4;
        const ENEMY_SPEED = 0.92; 
        
        let scene, camera, renderer, enemy, doorFrame, music;
        let mazeGrid = [];
        let isLocked = false, isGameOver = false;
        let velocityY = 0, canJump = true, pitch = 0;
        
        let stamina = 100;
        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false };

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02); 
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ'; 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Audio setup
            const listener = new THREE.AudioListener();
            camera.add(listener);
            music = new THREE.Audio(listener);
            const audioLoader = new THREE.AudioLoader();
            audioLoader.load('background horror music.mp3.mp3', function(buffer) {
                music.setBuffer(buffer);
                music.setLoop(true);
                music.setVolume(0.2);
            });

            createMaze();
            setupLights();
            
            document.addEventListener('pointerlockchange', lockChange);
            document.addEventListener('mousemove', mouseLook);
            document.addEventListener('keydown', (e) => handleKey(e, true));
            document.addEventListener('keyup', (e) => handleKey(e, false));
            window.addEventListener('resize', onResize);

            animate();
        }

        function setupLights() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const flashlight = new THREE.SpotLight(0xffffff, 4.5, 150, 0.5, 0.5, 1);
            camera.add(flashlight);
            camera.add(flashlight.target);
            flashlight.target.position.set(0, 0, -1);
            scene.add(camera);
        }

        function createMaze() {
            mazeGrid = Array(MAZE_SIZE).fill().map(() => Array(MAZE_SIZE).fill(1));
            const carve = (x, y) => {
                mazeGrid[y][x] = 0;
                const dirs = [[0,2],[0,-2],[2,0],[-2,0]].sort(() => Math.random() - 0.5);
                for(let [dx, dy] of dirs) {
                    let nx = x + dx, ny = y + dy;
                    if(nx > 0 && nx < MAZE_SIZE && ny > 0 && ny < MAZE_SIZE && mazeGrid[ny][nx] === 1) {
                        mazeGrid[y + dy/2][x + dx/2] = 0;
                        carve(nx, ny);
                    }
                }
            };
            carve(1, 1);

            const wallGeo = new THREE.BoxGeometry(WALL_SIZE, 20, WALL_SIZE);
            const wallMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            for(let z=0; z<MAZE_SIZE; z++) {
                for(let x=0; x<MAZE_SIZE; x++) {
                    if(mazeGrid[z][x] === 1) {
                        const wall = new THREE.Mesh(wallGeo, wallMat);
                        wall.position.set(x * WALL_SIZE, 2.5, z * WALL_SIZE);
                        scene.add(wall);
                    }
                }
            }
            
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(MAZE_SIZE * WALL_SIZE, MAZE_SIZE * WALL_SIZE), new THREE.MeshPhongMaterial({ color: 0x111111 }));
            floor.rotation.x = -Math.PI/2;
            floor.position.set((MAZE_SIZE*WALL_SIZE)/2 - WALL_SIZE/2, -7.5, (MAZE_SIZE*WALL_SIZE)/2 - WALL_SIZE/2);
            scene.add(floor);

            // Door
            doorFrame = new THREE.Group();
            const loader = new THREE.TextureLoader();
            const doorTexture = loader.load('YOUR_IMAGE_URL_HERE'); 
            const doorMat = new THREE.MeshPhongMaterial({ map: doorTexture, emissive: 0x111111 });
            const panel = new THREE.Mesh(new THREE.BoxGeometry(10, 15, 1), doorMat);
            doorFrame.add(panel);
            doorFrame.position.set((MAZE_SIZE-2)*WALL_SIZE, 0, (MAZE_SIZE-2)*WALL_SIZE);
            scene.add(doorFrame);

            // Enemy
            enemy = new THREE.Mesh(new THREE.BoxGeometry(6, 10, 6), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            enemy.position.copy(doorFrame.position);
            enemy.add(new THREE.PointLight(0xff0000, 5, 60));
            scene.add(enemy);
            
            camera.position.set(WALL_SIZE, PLAYER_HEIGHT, WALL_SIZE);
        }

        function startGame() {
            if (isGameOver) location.reload();
            else {
                document.body.requestPointerLock();
                if (music && !music.isPlaying) music.play();
                document.getElementById('stamina-container').style.display = 'block';
            }
        }

        function lockChange() {
            isLocked = (document.pointerLockElement === document.body);
            document.getElementById('msg').style.display = isLocked ? 'none' : 'block';
        }

        function mouseLook(e) {
            if (!isLocked || isGameOver) return;
            camera.rotation.y -= e.movementX * 0.002;
            pitch -= e.movementY * 0.002;
            pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, pitch));
            camera.rotation.x = pitch;
        }

        function handleKey(e, v) {
            if(e.code === 'Space') keys.space = v;
            if(e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.shift = v;
            const k = e.code.toLowerCase().replace('key','');
            if(keys.hasOwnProperty(k)) keys[k] = v;
        }

        function checkCol(x, z) {
            const gx = Math.round(x / WALL_SIZE);
            const gz = Math.round(z / WALL_SIZE);
            return (mazeGrid[gz] && mazeGrid[gz][gx] === 1);
        }

        function update() {
            if(!isLocked || isGameOver) return;

            // Stamina & Speed
            let speed = WALK_SPEED;
            if (keys.shift && stamina > 0 && (keys.w||keys.a||keys.s||keys.d)) {
                speed = RUN_SPEED;
                stamina -= 0.6;
            } else {
                stamina = Math.min(100, stamina + 0.2);
            }
            document.getElementById('stamina-bar').style.width = stamina + '%';

            // Movement
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            dir.y = 0; dir.normalize();
            const side = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0));
            let mx = 0, mz = 0;
            if(keys.w) { mx += dir.x; mz += dir.z; }
            if(keys.s) { mx -= dir.x; mz -= dir.z; }
            if(keys.d) { mx += side.x; mz += side.z; }
            if(keys.a) { mx -= side.x; mz -= side.z; }

            if(!checkCol(camera.position.x + mx * speed, camera.position.z)) camera.position.x += mx * speed;
            if(!checkCol(camera.position.x, camera.position.z + mz * speed)) camera.position.z += mz * speed;

            // Jump
            if(keys.space && canJump) { velocityY = 0.6; canJump = false; }
            velocityY -= 0.03; camera.position.y += velocityY;
            if(camera.position.y <= PLAYER_HEIGHT) { camera.position.y = PLAYER_HEIGHT; velocityY = 0; canJump = true; }

            // --- DYNAMIC DANGER LOGIC ---
            const edx = camera.position.x - enemy.position.x;
            const edz = camera.position.z - enemy.position.z;
            const dist = Math.sqrt(edx*edx + edz*edz);

            // Enemy Chase
            if(!checkCol(enemy.position.x + (edx/dist)*ENEMY_SPEED, enemy.position.z)) enemy.position.x += (edx/dist)*ENEMY_SPEED;
            if(!checkCol(enemy.position.x, enemy.position.z + (edz/dist)*ENEMY_SPEED)) enemy.position.z += (edz/dist)*ENEMY_SPEED;
            enemy.position.y = Math.sin(Date.now() * 0.005) * 2;

            // Audio & Visual Tension
            if (music && music.isPlaying) {
                // Volume goes up from 0.2 (dist 150) to 1.0 (dist 10)
                let vol = THREE.MathUtils.mapLinear(dist, 10, 150, 1.0, 0.2);
                music.setVolume(THREE.MathUtils.clamp(vol, 0.2, 1.0));
            }

            // Red Vignette Pulse
            const dangerIntensity = THREE.MathUtils.mapLinear(dist, 10, 80, 60, 0);
            document.getElementById('danger-overlay').style.boxShadow = `inset 0 0 ${dangerIntensity}px rgba(255, 0, 0, 0.8)`;

            // End Conditions
            if(dist < 6) endGame("DEVOURED BY THE GHOST", true);
            const distGoal = camera.position.distanceTo(doorFrame.position);
            if(distGoal < 12) endGame("YOU ESCAPED THE MAZE", false);
        }

        function endGame(text, isDead) {
            isGameOver = true;
            if (music) music.stop();
            document.exitPointerLock();
            document.getElementById('stamina-container').style.display = 'none';
            document.getElementById('danger-overlay').style.boxShadow = 'none';
            const msg = document.getElementById('msg');
            const title = document.getElementById('status-title');
            msg.style.display = 'block';
            title.innerText = text;
            title.style.color = isDead ? '#ff0000' : '#00ff00';
            document.getElementById('status-desc').innerText = "Click to Restart";
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }
        init();
    </script>
    // --- IMPROVED ENEMY AI WITH SLIDING COLLISION ---
const edx = camera.position.x - enemy.position.x;
const edz = camera.position.z - enemy.position.z;
const dist = Math.sqrt(edx * edx + edz * edz);

// Calculate intended velocity
const moveX = (edx / dist) * ENEMY_SPEED;
const moveZ = (edz / dist) * ENEMY_SPEED;

// 1. Try moving on X axis
if (!checkCol(enemy.position.x + moveX, enemy.position.z)) {
    enemy.position.x += moveX;
} 
// 2. Try moving on Z axis
if (!checkCol(enemy.position.x, enemy.position.z + moveZ)) {
    enemy.position.z += moveZ;
}

// Hovering effect
enemy.position.y = Math.sin(Date.now() * 0.005) * 2;
</body>
</html>